# Real Time Embedded System Timer

Timer in C/C++

Ένας Timer είναι μια υπορουτίνα που αυτόματα εκτελεί κώδικα ανά τακτά χρονικά διαστήματα.

Για να χρησιμοποιήσετε ένα timer, ακολουθήστε τα παρακάτω βήματα

    προσδιορίσετε τη συνάρτηση που θέλετε να εκτελείται περιοδικά ανά τακτά χρονικά διαστήματα
    φτιάξτε ένα timer object
    ξεκινήστε το timer object
    σβήστε το timer object όταν δεν το χρειάζεστε πια.

Ένα απλό μα πολύ κακό παράδειγμα είναι εδώ.

Δείτε το προσεκτικά γιατί θα βασιστούμε στις αρχές του.
Καλύτερη λύση

Θα υλοποιήσουμε το Timer, με δύο συναρτήσεις, που τρέχουν σε διαφορετικά νήματα producer και consumer.

Δείτε το producer-consumer παράδειγμα της Εργασίας 1.

Εδώ θα κάνουμε τις παρακάτω αλλαγές:

    producer να βάζει σε μια ουρά το δείκτη της συνάρτησης και δείκτη δεδομένων που πρέπει να εκτελεστεί εκείνη τη χρονική στιγμή, και τα αντίστοιχα δεδομένα, όταν έρχεται το πέρας μιας χρονικής περιόδου. Το νήμα που εκτελεί την producer, κάνει χρήση της usleep.

    consumer εκτελείται από νήματα-εργάτες. Τα νήματα αυτά μένουν αδρανή χωρίς να χρησιμοποιούν τη CPU μέχρι να μπει στην ουρά συνάρτηση προς εκτέλεση. Η ίδια ουρά και τα ίδια νήματα-εργάτες χρησιμοποιούνται από ένα ή περισσότερα αντικείμενα timer. Η εκτέλεση είναι χωρίς διακοπή --πέρα απο τυχόν διακοπές που επιβάλει το λειτουργικό σύστημα--, ένας εργάτης αναλαμβάνει και τελειώνει μια εργασία πριν να αναζητήσει επόμενη από την ουρά. Τα νήματα-εργάτες δημιουργούνται από το χρήστη όταν δημιουργείται το πρώτο αντικείμενο timer και τερματίζονται όταν δεν υπάρχουν αντικείμενα timer.

Specification

Να υλοποιηθούν οι παρακάτω λειτουργίες:

    Period: Ο χρόνος μεταξύ των κλήσεων της συνάρτησης TimerFcn, είναι ακέραιος μεγαλύτερος η ίσος του ένα, που δηλώνει χιλιοστά του δευτερολέπτου
    TasksToExecute: ακέραιος μη αρνητικός, πόσες φορές θα εκτελεστεί η συνάρτηση TimerFcn
    StartDelay: ακέραιος μη αρνητκός, πόσα δευτερόλεπτα θα περάσουν πριν να γίνει η πρώτη εκκίνηση της συνάρτησης TimerFcn
    StartFcn: συνάρτηση που εκτελείται κατά την κατασκευή του timer object για τυχόν αρχικοποίηση δεδομένων που χρειάζονται στη λειτουργία της συνάρτησης TimerFcn
    StopFcn: συνάρτηση που εκτελείται αμέσως μετά την τελευταία εκτέλεση της συνάρτησης TimerFcn
    TimerFcn: συνάρτηση που εκτελείται στην αρχή κάθε περιόδου
    ErrorFcn: συνάρτηση που εκτελείται αν γεμίσει η ουρά των συναρτήσεων που πρόκειται να εκτελεστούν
    UserData: δείκτης σε δεδομένα του χρήστη.

start(t) ξεκινά τον timer και την πρώτη εκτέλεση της συνάρτησης TimerFcn

startat(t,y,m,d,h,min,sec) ξεκινά τον timer και την πρώτη εκτέλεση της συνάρτησης TimerFcn τη χρονική στιγμή d/m/y h:min:sec.

Το παραπάνω είναι εμπνευσμένο από την αντίστοιχη συνάρτηση στο MATLAB και εκτέλεση fixed-rate.
Αντιμετώπιση της χρονικής μετατόπισης (drifting)

Θα παρατηρήσετε ότι με την παραπάνω υλοποίηση θα έχετε σταθερή μετατόπιση στον χρόνο (drifting) στα πειράματά σας. Για να το αντιμετωπίσετε, κάθε νήμα producer πρέπει να ελέγχει τον χρόνο που πέρασε από την προηγούμενη φορά που εκτελέστηκε, ώστε να ρυθμίσει κατάλληλα την νέα διάρκεια όταν καλεί την συνάρτηση usleep, με απώτερο σκοπό την διόρθωση της χρονικής μετατόπισης. Χρησιμοποιήστε την gettimeofday() για να ελέγξετε τον πραγματικό χρόνο ανάμεσα σε δύο διαδοχικές κλήσεις του νήματος producer.
Παραδοτέα

Να υλοποιηθεί το παραπάνω και να χρησιμοποιηθεί για τρεις ταυτόχρονες λειτουργίες timer με περιόδους: 1sec, 0.1sec και 0.01sec στο Raspberry Pi με την εικόνα του λειτουργικού που σας έχει δοθεί.

Να περιγραφεί σύντομα η υλοποίηση σας και να αναλυθούν τα αποτελέσματα των παρακάτω πειραμάτων. Να είστε σύντομοι κι ακριβείς.

Να κάνετε 4 πειράματα συνολικά, διάρκειας μιας ώρας το κάθε ένα. Να τρέξετε το κάθε task από μόνο του και μετά τα τρία task μαζί. Να συγκριθεί το drifting για κάθε περίοδο με την αντίστοιχη απομονομένη εκτέλεση.

Να καταγραφεί η στιγμή έναρξης κάθε εκτέλεσης TimerFcn με τη βοήθεια timestamps που επιστρέφει η συνάρτηση gettimeofday() για να μετρήστε το χρόνο (ελάχιστο, μέγιστο, μέσο όρο, διάμεσο, τυπική απόκλιση), που ξοδεύει η

    producer για να βάλει μία κλήση στην ουρά
    consumer για να βγάλει μία κλήση από την ουρά

Βρείτε τη χρήση της CPU που κάνει η διεργασία σας για κάθε πείραμα.

Τέλος, για λειτουργία πραγματικού χρόνου και έγκαιρη έναρξη, πόσο μεγάλη πρέπει να είναι η ουρά, μεχρι πόσο χρόνο να καταναλώνει η TimerFcn, με ποια περίοδο, και πόσοι πρέπει να είναι οι εργάτες;